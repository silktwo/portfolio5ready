Create a production-grade **Next.js 14 (App Router, TypeScript)** project for **Vercel** with universal caching and instant auto-updates from connected CMS platforms.

IMPORTANT:
- Do NOT create or overwrite `.env.local`. Use whatever already exists.
- Auto-detect connected CMSs from v0 (connectors) and/or existing environment variables.
- Support at least: **Notion, Contentful, Sanity, Strapi, Ghost, Hygraph (GraphCMS)**.
- If a CMS isn’t present, do not activate its adapter; silently skip it.

FUNCTIONALITY:
1) Cache / ISR
   - Global default: `revalidate = 1800` (30 minutes) for pages and data.
   - Cache data via `unstable_cache` with tags:
     - global tag: `cms:all`
     - per-collection tag: `cms:<collection>`
   - Do not use `cookies()/headers()`, `cache: 'no-store'`, or `dynamic='force-dynamic'` in pages (only in API routes).

2) CMS Adapters (auto-detect)
   - Create an interface `CMSAdapter` with methods:
     - `list(collection)`, `get(collection, slug)`,
     - `webhookToCollectionAndSlug(payload)`,
     - `tagFor(collection)`
   - Implement adapters: `notion`, `contentful`, `sanity`, `strapi`, `ghost`, `hygraph`.
   - On startup, initialize only adapters that have an available v0 connector and/or required env vars (do NOT create new env vars).
   - Configure collections and paths in `content.config.ts` (registry):
     `{ key, path('/key' | '/key/[slug]'), tag: 'cms:key', provider: 'notion'|'contentful'|... }`
   - If a provider exposes `slug` / `published` / `updated`, use them; otherwise fall back to the best available fields.

3) Universal pages
   - `/<collection>` — list view (uses the active adapter for that collection).
   - `/<collection>/<slug>` — detail view with Markdown/HTML rendering.
   - Both pages must export `revalidate = 1800`.

4) On-demand revalidate (instant)
   - API: `GET /api/revalidate` (set `dynamic='force-dynamic'`):
     - `?tag=cms:all` or `?collection=<key>` → `revalidateTag(...)`
     - `?path=/foo/bar` → `revalidatePath(...)`
     - `?warm=/,/works,/cases` (CSV) → immediately `fetch(..., { cache:'no-store' })` to warm those paths
     - Auth: `?secret=REVALIDATION_SECRET` or header `x-vercel-cron=1`

5) Webhooks (automatic on CMS changes)
   - Single endpoint per provider: `POST /api/webhook/[provider]` (set `dynamic='force-dynamic'`).
   - For each provider, implement signature verification per their spec (only if secrets exist in env).
   - Parse payload → via `adapter.webhookToCollectionAndSlug(payload)` determine:
     - which collections changed → `revalidateTag('cms:<collection>')`
     - if `slug` is known → `revalidatePath('/<collection>/<slug>')` + warm this path
   - Always also call `revalidateTag('cms:all')` as a safe broad invalidation.

6) Post-deploy refresh
   - Add a GitHub Action (optional, if the repo is on GitHub): on push to `main`, call
     `/api/revalidate?tag=cms:all&warm=/` with `REVALIDATION_SECRET`
     (read it from existing env, do not create a new one).

7) Fallback cron
   - `vercel.json` with an hourly cron calling `/api/revalidate?tag=cms:all`.

8) Transparent logging
   - On startup, log which CMSs were detected, which collections are active, and which tags will be used.

DEFINITION OF DONE:
- Default cache is 30 minutes, but any change from any connected CMS becomes visible immediately (webhook → `revalidateTag`/`revalidatePath` + warm).
- Manual `/api/revalidate` works for `tag` / `collection` / `path` and supports warming.
- If multiple CMSs are connected, all collections behave uniformly (shared `cms:*` tag scheme).
- `.env.local` is untouched (read-only). If some secrets are missing, the corresponding adapters are simply not activated without throwing errors.

Generate all files and code to satisfy this spec.